<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_CASE_DuplicatCheck" Id="{90819285-d265-4c2d-b3b2-65e65ef5bf07}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_CASE_DuplicatCheck
VAR_INPUT
	bExecute	: BOOL;
END_VAR
VAR_IN_OUT

	stProductInstruction				: ST_PCM_Status;
	
	stPackCodesDuplicated			: ST_RejectItems;
	stOuterBarcodeDuplicate			: ST_RejectItems;
	stOuterDuplicatedPackCodesFound	: ST_RejectItems;
	stCaseRejectReasons			: ST_RejectReasonsForCase;
	
	stCACData 						: ST_CAC_Data;
END_VAR
VAR_OUTPUT
	bDone 					: BOOL;
	bBusy					: BOOL;

	bCACValid				: BOOL;
	sRejectCode				: T_MaxString;
	bIsDuplicateOuters		: BOOL;
	bIsDuplicatePacks		: BOOL;
	bReadyToValidate		: BOOL;
	
	stUpdateCACData 		: ST_CAC_Data;
END_VAR
VAR

	rtExecute	: R_TRIG;
	
	nOuterIndex			: INT;
	nPackIndex			: INT;
	nOuterCheckIndex	: INT;
	nPackCheckIndex		: INT;
	
	nDuplicateOuter1_Position	: INT;
	nDuplicateOuter2_Position	: INT;
	nDuplicatePack1_Position	: INT;
	nDuplicatePack2_Position	: INT;
	
	aStatusErrorVal					: ARRAY[0..10] OF STRING(10);
	aRejectCodePointer     		   	: ARRAY[0..10] OF STRING(10);
	
	nIteration				: UDINT;
	nIterationAI			: UDINT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[rtExecute(CLK:=bExecute);

IF rtExecute.Q THEN
	
	(* update outputs *)
	bDone := TRUE;
	bBusy := TRUE;

	bIsDuplicateOuters:= FALSE;
	bIsDuplicatePacks:= FALSE;
	
	MEMSET(ADR(aStatusErrorVal), 16#00, SIZEOF(aStatusErrorVal));
	MEMSET(ADR(aRejectCodePointer), 16#00, SIZEOF(aRejectCodePointer));
	
	bReadyToValidate	:= FALSE;
	MEMSET(ADR(stUpdateCACData), 16#00, SIZEOF(stUpdateCACData));
	

	nDuplicateOuter1_Position :=0;
	nDuplicateOuter2_Position:=0;
	nDuplicatePack1_Position:=0;
	nDuplicatePack2_Position:=0;

	(* clear outputs *)
	bCACValid := FALSE;
	sRejectCode := '';
	
	nIteration		:= 0;
	nIterationAI	:= 0;
(*
	(* Loop throught all packs in one case 'stCase' *)
	FOR nOuterIndex := 1 TO MIN(stProductInstruction.nOutersPerCase,cMAX_OUTERS_PER_CASE) BY 1 DO
		FOR nPackIndex := 1 TO MIN(stProductInstruction.nPacksPerOuter, cMAX_PACKS_PER_OUTER) BY 1 DO			
			(* Looking for same pack codes in all outers *)
			FOR nOuterCheckIndex := nOuterIndex TO MIN(stProductInstruction.nOutersPerCase,cMAX_OUTERS_PER_CASE) BY 1 DO
				
				IF stCACData.Outer[nOuterIndex].Barcode = stCACData.Outer[nOuterCheckIndex].Barcode AND 
					stCACData.Outer[nOuterIndex].Barcode <> ''										AND 
					NOT (nOuterCheckIndex = nOuterIndex) 											THEN
				 
					IF NOT bIsDuplicateOuters THEN
						nDuplicateOuter1_Position := nOuterIndex;
						nDuplicateOuter2_Position := nOuterCheckIndex;
					END_IF
						
					bIsDuplicateOuters := TRUE; 
					
					stCACData.Outer[nOuterIndex].OuterRejectCode 	:=	stOuterBarcodeDuplicate.sMetsDisplayCode;
					stCACData.Outer[nOuterIndex].OuterRejectID		:=	stOuterBarcodeDuplicate.nRejectID;
		
					stCACData.Outer[nOuterCheckIndex].OuterRejectCode 	:=	stOuterBarcodeDuplicate.sMetsDisplayCode;
					stCACData.Outer[nOuterCheckIndex].OuterRejectID		:=	stOuterBarcodeDuplicate.nRejectID;
				END_IF
				
				FOR nPackCheckIndex := 1 TO MIN(stProductInstruction.nPacksPerOuter, cMAX_PACKS_PER_OUTER) BY 1 DO
					nIterationAI := nIterationAI + 1;					
					(* Exclude comparing same pack with itself *)
					IF stCACData.Outer[nOuterIndex].PackCode[nPackIndex] = stCACData.Outer[nOuterCheckIndex].PackCode[nPackCheckIndex] 	AND 
						stCACData.Outer[nOuterIndex].PackCode[nPackIndex]  <> ''														AND 
						stCACData.Outer[nOuterCheckIndex].PackRejectID[nPackCheckIndex] <> stPackCodesDuplicated.nRejectID 				AND 
						NOT ((nOuterCheckIndex = nOuterIndex) AND (nPackCheckIndex = nPackIndex)) 										THEN
						
						IF NOT bIsDuplicatePacks AND NOT bIsDuplicateOuters THEN
							nDuplicateOuter1_Position := nOuterIndex;
							nDuplicateOuter2_Position :=  nOuterCheckIndex;
							nDuplicatePack1_Position := nPackIndex;
							nDuplicatePack2_Position := nPackCheckIndex;
						END_IF
							
						bIsDuplicatePacks := TRUE;
						stCACData.Outer[nOuterIndex].OuterRejectCode 	:= stOuterDuplicatedPackCodesFound.sMetsDisplayCode;
						stCACData.Outer[nOuterIndex].OuterRejectID		:= stOuterDuplicatedPackCodesFound.nRejectID;
						
						stCACData.Outer[nOuterCheckIndex].OuterRejectCode 	:= stOuterDuplicatedPackCodesFound.sMetsDisplayCode;
						stCACData.Outer[nOuterCheckIndex].OuterRejectID		:= stOuterDuplicatedPackCodesFound.nRejectID;
						
						stCACData.Outer[nOuterIndex].PackCodeStatus[nPackIndex] :=
											F_FiltredSetBitState16(TRUE, 'LOW', 3, TRUE, stCACData.Outer[nOuterIndex].PackCodeStatus[nPackIndex]);
						
						stCACData.Outer[nOuterIndex].PackRejectCode[nPackIndex]		:= stPackCodesDuplicated.sMetsDisplayCode;
						stCACData.Outer[nOuterIndex].PackRejectID[nPackIndex]		:= stPackCodesDuplicated.nRejectID;
						
						stCACData.Outer[nOuterCheckIndex].PackCodeStatus[nPackCheckIndex] :=
											F_FiltredSetBitState16(TRUE, 'LOW', 3, TRUE, stCACData.Outer[nOuterCheckIndex].PackCodeStatus[nPackCheckIndex]);
						
						stCACData.Outer[nOuterCheckIndex].PackRejectCode[nPackCheckIndex]	:= stPackCodesDuplicated.sMetsDisplayCode;
						stCACData.Outer[nOuterCheckIndex].PackRejectID[nPackCheckIndex]		:= stPackCodesDuplicated.nRejectID;
					END_IF
				END_FOR
			END_FOR			
		END_FOR
	END_FOR
	*)

//////////////////////	
	FOR nOuterIndex := 1 TO MIN(stProductInstruction.nOutersPerCase,cMAX_OUTERS_PER_CASE) BY 1 DO
	//////////////////////		
		FOR nOuterCheckIndex := nOuterIndex + 1 TO MIN(stProductInstruction.nOutersPerCase,cMAX_OUTERS_PER_CASE) BY 1 DO
			
			IF stCACData.Outer[nOuterIndex].Barcode = stCACData.Outer[nOuterCheckIndex].Barcode AND 
				stCACData.Outer[nOuterIndex].Barcode <> ''	THEN
				 
			 	IF NOT bIsDuplicateOuters THEN
					nDuplicateOuter1_Position := nOuterIndex;
					nDuplicateOuter2_Position := nOuterCheckIndex;
				END_IF
					
				bIsDuplicateOuters := TRUE; 
				
				stCACData.Outer[nOuterIndex].OuterRejectCode 	:=	stOuterBarcodeDuplicate.sMetsDisplayCode;
				stCACData.Outer[nOuterIndex].OuterRejectID		:=	stOuterBarcodeDuplicate.nRejectID;
	
				stCACData.Outer[nOuterCheckIndex].OuterRejectCode 	:=	stOuterBarcodeDuplicate.sMetsDisplayCode;
				stCACData.Outer[nOuterCheckIndex].OuterRejectID		:=	stOuterBarcodeDuplicate.nRejectID;
			 END_IF
			 nIteration := nIteration + 1;
		END_FOR
		///////////////////////////
		FOR  nPackIndex :=1 TO MIN(stProductInstruction.nPacksPerOuter, cMAX_PACKS_PER_OUTER) BY 1 DO
			FOR nPackCheckIndex := nPackIndex + 1  TO MIN(stProductInstruction.nPacksPerOuter, cMAX_PACKS_PER_OUTER) BY 1 DO
				
				IF stCACData.Outer[nOuterIndex].PackCode[nPackIndex] = stCACData.Outer[nOuterIndex].PackCode[nPackCheckIndex] AND 
					stCACData.Outer[nOuterIndex].PackCode[nPackIndex]  <> ''										AND 
					stCACData.Outer[nOuterIndex].PackRejectID[nPackCheckIndex] <> stPackCodesDuplicated.nRejectID 	THEN
					
					IF NOT bIsDuplicatePacks AND NOT bIsDuplicateOuters THEN
						nDuplicateOuter1_Position := nOuterIndex;
						nDuplicateOuter2_Position :=  nOuterIndex;
						nDuplicatePack1_Position := nPackIndex;
						nDuplicatePack2_Position := nPackCheckIndex;
					END_IF
						
					bIsDuplicatePacks := TRUE;
					stCACData.Outer[nOuterIndex].OuterRejectCode 	:= stOuterDuplicatedPackCodesFound.sMetsDisplayCode;
					stCACData.Outer[nOuterIndex].OuterRejectID		:= stOuterDuplicatedPackCodesFound.nRejectID;
					
					stCACData.Outer[nOuterIndex].PackCodeStatus[nPackIndex] :=
											F_FiltredSetBitState16(TRUE, 'LOW', 3, TRUE, stCACData.Outer[nOuterIndex].PackCodeStatus[nPackIndex]);
											
					stCACData.Outer[nOuterIndex].PackRejectCode[nPackIndex]		:= stPackCodesDuplicated.sMetsDisplayCode;
					stCACData.Outer[nOuterIndex].PackRejectID[nPackIndex]		:= stPackCodesDuplicated.nRejectID;
					
					stCACData.Outer[nOuterIndex].PackCodeStatus[nPackCheckIndex] :=
											F_FiltredSetBitState16(TRUE, 'LOW', 3, TRUE, stCACData.Outer[nOuterIndex].PackCodeStatus[nPackCheckIndex]);
					
					stCACData.Outer[nOuterIndex].PackRejectCode[nPackCheckIndex]	:= stPackCodesDuplicated.sMetsDisplayCode;
					stCACData.Outer[nOuterIndex].PackRejectID[nPackCheckIndex]		:= stPackCodesDuplicated.nRejectID;
				END_IF
				nIteration := nIteration + 1;
			END_FOR
			/////////////////////////////////
			FOR nOuterCheckIndex := nOuterIndex + 1 TO MIN(stProductInstruction.nOutersPerCase,cMAX_OUTERS_PER_CASE) BY 1 DO
				FOR nPackCheckIndex := 1  TO MIN(stProductInstruction.nPacksPerOuter, cMAX_PACKS_PER_OUTER) BY 1 DO

					IF stCACData.Outer[nOuterIndex].PackCode[nPackIndex] = stCACData.Outer[nOuterCheckIndex].PackCode[nPackCheckIndex] AND 
						stCACData.Outer[nOuterIndex].PackCode[nPackIndex]  <> ''									AND 
						stCACData.Outer[nOuterCheckIndex].PackRejectID[nPackCheckIndex] <> stPackCodesDuplicated.nRejectID 	THEN
						
						IF NOT bIsDuplicatePacks AND NOT bIsDuplicateOuters THEN
							nDuplicateOuter1_Position := nOuterIndex;
							nDuplicateOuter2_Position :=  nOuterCheckIndex;
							nDuplicatePack1_Position := nPackIndex;
							nDuplicatePack2_Position := nPackCheckIndex;
						END_IF
							
						bIsDuplicatePacks := TRUE;
						stCACData.Outer[nOuterIndex].OuterRejectCode 	:= stOuterDuplicatedPackCodesFound.sMetsDisplayCode;
						stCACData.Outer[nOuterIndex].OuterRejectID		:= stOuterDuplicatedPackCodesFound.nRejectID;
						
						stCACData.Outer[nOuterCheckIndex].OuterRejectCode 	:= stOuterDuplicatedPackCodesFound.sMetsDisplayCode;
						stCACData.Outer[nOuterCheckIndex].OuterRejectID		:= stOuterDuplicatedPackCodesFound.nRejectID;
						
						stCACData.Outer[nOuterIndex].PackCodeStatus[nPackIndex] :=
											F_FiltredSetBitState16(TRUE, 'LOW', 3, TRUE, stCACData.Outer[nOuterIndex].PackCodeStatus[nPackIndex]);
						
						stCACData.Outer[nOuterIndex].PackRejectCode[nPackIndex]		:= stPackCodesDuplicated.sMetsDisplayCode;
						stCACData.Outer[nOuterIndex].PackRejectID[nPackIndex]		:= stPackCodesDuplicated.nRejectID;
						
						stCACData.Outer[nOuterCheckIndex].PackCodeStatus[nPackCheckIndex] :=
											F_FiltredSetBitState16(TRUE, 'LOW', 3, TRUE, stCACData.Outer[nOuterCheckIndex].PackCodeStatus[nPackCheckIndex]);
						
						stCACData.Outer[nOuterCheckIndex].PackRejectCode[nPackCheckIndex]	:= stPackCodesDuplicated.sMetsDisplayCode;
						stCACData.Outer[nOuterCheckIndex].PackRejectID[nPackCheckIndex]		:= stPackCodesDuplicated.nRejectID;
					END_IF
					nIteration := nIteration + 1;
				END_FOR
			END_FOR
		/////////////////////////////////		
		END_FOR
	//////////////////////	
	END_FOR
//////////////////////	


	IF bIsDuplicateOuters THEN
		
		aStatusErrorVal[0] := 	F_StringAddPrefix(INT_TO_STRING(nDuplicateOuter1_Position),2,'0');
		aStatusErrorVal[1] := 	F_StringAddPrefix(INT_TO_STRING(nDuplicateOuter2_Position),2,'0');
		aRejectCodePointer[0] := 'n1';
		aRejectCodePointer[1] := 'n2';
		
		stCACData.CaseRejectCode 	:=	F_CODE_AssignValToStringWithPrefix(stCaseRejectReasons.stDUPError.sMetsDisplayCode, aStatusErrorVal, aRejectCodePointer, 2, '0');
		stCACData.CaseRejectID	:= 	stCaseRejectReasons.stDUPError.nRejectID;
	
		sRejectCode := stCACData.CaseRejectCode;
		
	ELSIF bIsDuplicatePacks THEN
		
		aStatusErrorVal[0] := 	F_CONCAT4(F_StringAddPrefix(INT_TO_STRING(nDuplicateOuter1_Position),2,'0'),'(', F_StringAddPrefix(INT_TO_STRING(nDuplicatePack1_Position),2,'0'),')');
		aStatusErrorVal[1] := 	F_CONCAT4(F_StringAddPrefix(INT_TO_STRING(nDuplicateOuter2_Position),2,'0'),'(', F_StringAddPrefix(INT_TO_STRING(nDuplicatePack2_Position),2,'0'),')');
		aRejectCodePointer[0] := 'n1';
		aRejectCodePointer[1] := 'n2';

		stCACData.CaseRejectCode 	:=	F_CODE_AssignValToStringWithPrefix(stCaseRejectReasons.stDUPError.sMetsDisplayCode, aStatusErrorVal, aRejectCodePointer, 6, '0');
		stCACData.CaseRejectID		:= stCaseRejectReasons.stDUPError.nRejectID;
		
		sRejectCode := stCACData.CaseRejectCode;
	ELSE
		bCACValid := TRUE;
	END_IF
	
	bReadyToValidate	:= TRUE;
	MEMMOVE(ADR(stUpdateCACData), ADR(stCACData), SIZEOF(stUpdateCACData));
	
ELSIF bExecute = FALSE THEN
	
	(* clear outputs *)
	bDone := FALSE;
	bBusy := FALSE;

END_IF			]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>