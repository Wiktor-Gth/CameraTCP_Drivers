<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_SCANNER_HikrobotEXT" Id="{2eca3199-12e6-42e0-b507-63e823613e71}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_SCANNER_HikrobotEXT
VAR_INPUT
	bEnableReceive					: BOOL;
	bEnableSend						: BOOL;
	strScannerIPAddr				: T_IPv4Addr	:= '192.168.1.45';
	nReceiveScannerPortNo			: UINT			:= 2010;
	nSendScannerPortNo				: UINT			:= 4001;	
	stRequestCommand				: E_TCPIP_RequescCommand; (* tutaj powinna byc strukruta z eRequestCommand plus parametry: 0,1 etc *)
	bSendCommand					: BOOL;
	bExecutedCommandSend			: BOOL;
END_VAR

VAR_OUTPUT
	eSocketReceiveState		: E_SocketConnectionState;
	eSocketSendState		: E_SocketConnectionState;
END_VAR

VAR
	fbTCPPortCtrl_Receive	: FB_TCP_ClientPortCtrl;
	bReceiveConnected		: BOOL;
	fbTCPortCtrl_Send		: FB_TCP_ClientPortCtrl;
	bSendConnected			: BOOL;
	fbTCPReceive			: FB_ReceiveString;
	bReceiveExpected		: BOOL;
	fbTCPReceiveAfterSend	: FB_ReceiveString;	
	strTCPRxStringReply		: T_MaxString;
	strTCPRxString			: T_MaxString;
	strTCPRxString_Reply	: T_MaxString;
	ftrigEnable				: F_TRIG;
	bReInitialiseTCP		: BOOL;
	fbTON_TcpTimeout		: TON;
	
	nIndex					: UINT;
	nIndexReply				: UINT;
	nIndex2					: UINT;
	
	/////// send command
	
	fbTCPSend				: FB_SocketSend;
	rTrigSend				: R_TRIG;
	rTrigDataReceived		: R_TRIG;
	rTrigSendCommand		: R_TRIG;
	nCommandNo				: UINT := 1;
	fTrigTCPSendDone		: F_TRIG;
	nSendErrId				: UDINT;
	strTCPCommand			: STRING(20);
	strReplyString			: STRING(20);
	strTCPLastCommand		: STRING(20);
	strLastReplyString		: STRING(20);
	bReplyOK				: BOOL;
	tHeartbeatInterval		: TIME := T#5S;
	eRequestCommand			: E_TCPIP_RequescCommand;
	
	(* SEND SEQUENCE VARIABLE *)
	
	eSendSequenceSTATE		: E_TCPIP_SEND_STATE;
	bSendRequest			: BOOL;
	rTrigSendRequest		: R_TRIG;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
Connect();

Receive();

//Send();

Send_Sequence();

]]></ST>
    </Implementation>
    <Action Name="Connect" Id="{19033c27-8bdc-4ad1-b4f2-22164cb8860c}">
      <Implementation>
        <ST><![CDATA[
(* TCP Receive Socket establish connect *)
fbTCPPortCtrl_Receive(
	bEnable				:= bEnableReceive, 
	strRemoteIPAddr		:= strScannerIPAddr, 
	nRemotePortNo		:= nReceiveScannerPortNo, 
	tReconnectTime		:= T#20S, 
	eSocketState		=> eSocketReceiveState, 
	bError				=> , 
	nErrorID			=>,
	bConnected			=> bReceiveConnected
 );
	
(* TCP Send Socket establish connect *)
fbTCPortCtrl_Send(
	bEnable				:= bEnableSend, 
	strRemoteIPAddr		:= strScannerIPAddr, 
	nRemotePortNo		:= nSendScannerPortNo, 
	tReconnectTime		:= T#20S, 
	eSocketState		=> eSocketSendState, 
	bError				=> , 
	nErrorID			=>, 
	bConnected			=> bSendConnected
);]]></ST>
      </Implementation>
    </Action>
    <Action Name="Receive" Id="{708aaa89-8818-4a32-bfe8-6fffb45be551}">
      <Implementation>
        <ST><![CDATA[
ftrigEnable(CLK := bEnableReceive);
IF ftrigEnable.Q THEN
	strTCPRxString := ''; (* clears input buffer *)
END_IF

(* poll TCP port receive string *)
fbTCPReceive(
	bEnable			:= fbTCPPortCtrl_Receive.bConnected,
	hSocket			:= fbTCPPortCtrl_Receive.hSocket,
	tUpdateTime		:= T#100MS,
	strTCPRxString	:= strTCPRxString
);


//*************** quick patch ****************//
IF fbTCPReceive.bDataReceived THEN
	GVL.aTCPxStrings[nIndex] := strTCPRxString;
	nIndex := nIndex + 1;
	strTCPRxString := '';
END_IF
	
IF nIndex = 20 THEN
	nIndex := 0;
	FOR nIndex2 := 0 TO 20 DO
		GVL.aTCPxStrings[nIndex2] := '';		
	END_FOR
END_IF

IF nIndexReply = 20 THEN
	nIndexReply := 0;
	FOR nIndex2 := 0 TO 20 DO
		GVL.aTCPxStringsReply[nIndex2] := '';		
	END_FOR
END_IF

//*************** quick patch ****************//]]></ST>
      </Implementation>
    </Action>
    <Action Name="Send" Id="{4218bcf5-c66e-417f-ac74-e628208b0859}">
      <Implementation>
        <ST><![CDATA[
rTrigSend(CLK := bSendCommand);
IF rTrigSend.Q THEN
	strTCPCommand 	:= GVL.aHikrobotCtrlCommands[nCommandNo];	
END_IF

fbTCPSend(
	sSrvNetId	:= '',
	hSocket		:= fbTCPortCtrl_Send.hSocket,
	cbLen		:= TO_UDINT(LEN(strTCPCommand)),
	pSrc		:= ADR(strTCPCommand),
	bExecute	:= rTrigSend.Q,
	tTimeout	:= T#1s
);

(* send data complete *)
fTrigTCPSendDone(CLK := fbTCPSend.bBusy);
(* TCP send complete *)

IF fbTCPSend.bError = TRUE THEN
	nSendErrId := fbTCPSend.nErrId;
ELSE
	nSendErrId := 0;	
END_IF

IF fTrigTCPSendDone.Q = TRUE THEN

	(* clear strTCPCommand *)
	strTCPCommand := '';

	(* close off fbSendTCPData *)
	fbTCPSend(bExecute := FALSE);
END_IF


// expece response after sending command
fbTCPReceiveAfterSend(
	bEnable			:= bSendCommand AND fbTCPortCtrl_Send.bConnected,
	hSocket			:= fbTCPortCtrl_Send.hSocket,
	tUpdateTime		:= T#100MS,
	strTCPRxString	:= strTCPRxString_Reply
);]]></ST>
      </Implementation>
    </Action>
    <Action Name="Send_Sequence" Id="{fd76404e-ad87-43d3-962c-875000359259}">
      <Implementation>
        <ST><![CDATA[
rTrigSendCommand(CLK := bSendCommand);

IF rTrigSendCommand.Q  THEN	
	IF stRequestCommand <> 0 THEN
		eRequestCommand	:= stRequestCommand;
	END_IF	
END_IF

fbTCPSend(
	sSrvNetId	:= '',
	hSocket		:= fbTCPortCtrl_Send.hSocket,
	cbLen		:= TO_UDINT(LEN(strTCPCommand)),
	pSrc		:= ADR(strTCPCommand),
	bExecute	:= fbTCPSend.cbLen > 0 AND fbTCPSend.bBusy = FALSE,
	tTimeout	:= T#1S
);
	
	(* send data complete *)
fTrigTCPSendDone(CLK := fbTCPSend.bBusy);
IF fTrigTCPSendDone.Q = TRUE THEN

	IF fbTCPSend.bError = TRUE THEN
		bReInitialiseTCP := TRUE;
	END_IF

	strTCPLastCommand 	:= strTCPCommand;
	strLastReplyString	:= strReplyString;
	eRequestCommand 	:= E_TCPIP_RequescCommand.NONE;
	(* close off fbSendTCP *)
	fbTCPSend(bExecute 	:= FALSE);
	
	(* expece to receive reply after send finished *)
	bReceiveExpected	:= TRUE;
	
END_IF

fbTCPReceiveAfterSend(
	bEnable			:= fbTCPortCtrl_Send.bConnected,
	hSocket			:= fbTCPortCtrl_Send.hSocket,
	tUpdateTime		:= T#100MS,
	strTCPRxString	:= strTCPRxStringReply
);

rTrigDataReceived(CLK:=fbTCPReceiveAfterSend.bDataReceived);
IF rTrigDataReceived.Q THEN
	(*  veryfi valide response *)
	
	IF strLastReplyString = strTCPRxStringReply THEN
		bReplyOK := TRUE;
	ELSE		
		bReplyOK := FALSE;			
	END_IF
	
	GVL.aTCPxStringsReply[nIndexreply] 	:= strTCPRxStringReply;
	nIndexReply	 						:= nIndexReply + 1;
	strTCPRxStringReply 				:= '';
	bReceiveExpected					:= FALSE;
	
END_IF

// HeartBeat send every tHeartbeatInterval, if heartbead doesent reply do bReInitialiseTCP := TRUE
fbTON_TcpTimeout(
	IN	:= fbTCPortCtrl_Send.bConnected,
 	PT	:= tHeartbeatInterval
);
IF fbTON_TcpTimeout.Q AND (eRequestCommand = E_TCPIP_RequescCommand.NONE) THEN
	eRequestCommand 	:= E_TCPIP_RequescCommand.HeartbeatCheck;	
	fbTON_TcpTimeout(IN := FALSE);
END_IF
//////////////////////////// heartbeat handeling end ///////////////////////////////////////////////

CASE eRequestCommand OF
	
	E_TCPIP_RequescCommand.NONE:		
		strTCPCommand 	:= '';	
		strReplyString	:= '';		
	
	E_TCPIP_RequescCommand.GetUserCur:		
		strTCPCommand 	:= '<Get,UserCur>';	
		strReplyString	:= '<Get,UserCur,6>';	
		
	E_TCPIP_RequescCommand.WrongReply:		
		strTCPCommand 	:= '<Get,UserCur>';	
		strReplyString	:= '<Get,UserCur,2>';
	
	E_TCPIP_RequescCommand.HeartbeatCheck:		
		strTCPCommand 	:= '<Get,RunMode>';	
		strReplyString	:= '<Get,RunMode,0>';		
		
	E_TCPIP_RequescCommand.SetAquisitonModeON:
		strTCPCommand 	:= '<Set,Acq,1>';	
		strReplyString	:= '<Set,Acq,OK>';	
		
	E_TCPIP_RequescCommand.SetAquisitionModeOFF:
		strTCPCommand 	:= '<Set,Acq,0>';	
		strReplyString	:= '<Set,Acq,OK>';
	
END_CASE]]></ST>
      </Implementation>
    </Action>
  </POU>
</TcPlcObject>